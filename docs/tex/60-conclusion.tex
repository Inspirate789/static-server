\part*{ЗАКЛЮЧЕНИЕ}
\addcontentsline{toc}{part}{\textbf{ЗАКЛЮЧЕНИЕ}} 

В рамках курсовой работы был разработан статический сервер, который на большинстве сценариев использования оказался сравнимым по производительности с NGINX.

В ходе выполнения данной работы были решены следующие задачи.

\begin{enumerate}[label*=\arabic*.]
	\item Проведён анализ предметной области и формализована задача.
	\item Спроектирована структура программного обеспечения.
	\item Реализовано программное обеспечение, которое обслуживает контент, хранящийся во вторичной памяти. 
	\item Проведено нагрузочное тестирование и сравнение с распространёнными аналогами.
\end{enumerate}

Таким образом, все поставленные задачи были выполнены, поставленная цель достигнута.

%Большинство современных языков программирования строятся на одной из трех ссылочных моделей:
%
%Первая категория это языки с ручным управлением временем жизни объектов. Примеры — C/C++/Zig. В этих языках объекты аллоцируются и освобождаются вручную, а указатель — это просто адрес памяти, никого ни к чему не обязывающий.
%
%Во вторую категорию попадают языки с подсчетом ссылок. Это Оbjective-C, Swift, Частично Rust, C++ при использовании умных указателей и некоторые другие. Эти языки позволяют автоматизировать до некоторой степени удаление ненужных объектов. Но это имеет свою цену. В многопоточный среде такие счетчики ссылок должны быть атомарными, а это дорого. К тому же, подсчет ссылок не может освободить все виды мусора. Когда объект А ссылается на объект Б а объект Б обратно ссылается на объект А такая закольцованная иерархия не может быть удалена подсчетом ссылок. Такие языки как Rust, Swift вводят дополнительные не владеющие ссылки которые решают проблему закольцовок ценой усложнения объектной модели и синтаксиса.
%
%В третью категорию попадают большинство современных языков программирования. Это языки с автоматической сборкой мусора: Java, JavaScript, Kotlin, Python, Lua... В этих языках ненужные объекты удаляются автоматически, но есть нюанс. Сборщик мусора потребляет очень много памяти и процессорного времени. Он включается в случайные моменты времени и ставит основную программу на паузу. Иногда полностью — на все свое время работы, иногда частично. Сборки мусора без пауз не существует. Гарантию сборки всего мусора может дать только алгоритм который просматривает всю память и останавливает приложение на все свое время работы. В реальной жизни такие сборщики давно не используются ввиду своей неэффективности. В современных системах некоторые мусорные объекты не удаляются вообще.
%
%Кроме того, само определение ненужного объекта нуждается в уточнении. Если, например, у нас есть GUI-приложение, и вы убираете с формы какой-то управляющий элемент, подписанный на события таймера, он не может быть удален просто так потому что где-то в объекте таймера хранится ссылка на этот объект, и сборщик мусора не будет считать такой объект мусором.
%
%Как уже говорилось выше, каждая из трех ссылочных моделей имеет свои недостатки. В первом случае имеем дыры в memory safety и  утечки памяти, во втором случае мы имеем медленную работу в многопоточной среде и утечки памяти из-за закольцовок, в третьем получаем спорадические остановки программы сильное потребление памяти, процессора и необходимость ручного разрыва ссылок когда объект становится не нужным. К тому же система с подсчетом ссылок и сборкой мусора не позволяют управлять временем жизни других ресурсов — таких как открытые файловые дескрипторы, идентификаторы окон, процессов, шрифтов и так далее. Эти методы рассчитаны только на память. Есть еще одна проблема систем со сборкой мусора — виртуальная память. В условиях, когда программная система накапливает мусор, а затем сканирует память для его освобождения, вытеснение части адресного пространства на внешний носитель может полностью убить производительность приложения. Поэтому сборка мусора не совместима с виртуальной памятью.
%
%То есть проблемы есть и текущие методы их решения имеют изъяны.
%
%
%
%cornell2:
%
%В документе представлена ​​эта структура, показано, что трассировка и подсчет ссылок на самом деле двойственны, показано, как оптимизированные сборщики мусора представляют собой гибриды трассировки и подсчета ссылок, а также представлен анализ затрат для определения компромисса между временем и пространством сборщиков в этом пространстве проектирования.